25-08-2021(wed) #day 10

postgres=# \c day9
You are now connected to database "day9" as user "postgres".
day9=# create table taazaatraining(
day9(# id int generated always as identity,
day9(# name varchar(50),
day9(# address varchar(50),
day9(# age int);
CREATE TABLE

after lunch
DATE,array,smallint,time,char,numeric DATATYPE


before lunch

1) update


day9=# update taazaatraining set name='das sukhdev' where id=1;
UPDATE 1
day9=# select * from taazaatraining;
 id |    name     |  address  | age
----+-------------+-----------+-----
  2 | sukhdev     | new delhi |  22
  3 | Rahul       | Noida     |  23
  1 | das sukhdev | new delhi |  22
(3 rows)


day9=# update taazaatraining set name='das sukhdev' where id=2;
UPDATE 1
day9=# update taazaatraining set name='Gurpreet singh' where id=1;
UPDATE 1
day9=# select * from taazaatraining;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  2 | das sukhdev    | new delhi |  22
  1 | Gurpreet singh | new delhi |  22
(3 rows)


2) delete
3) where

day9=# delete from taazaatraining where id=2;
DELETE 1
day9=# delete from taazaatraining where id=1;
DELETE 1
day9=# insert into taazaatraining(name,address,age) values('Gurpreet Singh','new delhi',22);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('sukhdev','new delhi',22);
INSERT 0 1
day9=# delete from taazaatraining where id=2;
DELETE 0
day9=# select * from taazaatraining;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
(3 rows)



4) order by

day9=# select * from taazaatraining order by id;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
(3 rows)


day9=# select * from taazaatraining order by address;
 id |      name      |  address  | age
----+----------------+-----------+-----
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  3 | Rahul          | Noida     |  23
(3 rows)


5) * group by
GROUP BY clause in PostgreSQL. We also see examples of how GROUP BY clause working with SUM() function, COUNT(), JOIN clause, multiple columns, and the without an aggregate function.

every group can apply an aggregate function like COUNT() function is used to get the number of items in the groups, and the SUM() function is used to analyze the sum of items.


6) * having

The having clause is used to specify a search condition for a group or an aggregate. And it is regularly used with the GROUP BY clause to filter groups or aggregates based on a detailed condition.


7) distinct

the DISTINCT clause will analyze the matching rows or data according to the grouping of these column's values.

day9=# select address from taazaatraining group by address;
  address
-----------
 new delhi
 Noida
(2 rows)



day9=# select count(address) from taazaatraining group by address having address='new delhi';
 count
-------
     2
(1 row)


day9=# select distinct(address) from taazaatraining ;
  address
-----------
 new delhi
 Noida
(2 rows)


8) limit

LIMIT clause, which is used to get a subset of rows produced by a command.
In the above syntax, Limit clause returns row_count rows created by the command.

If a limit count is given, no more than that many rows will be returned (but possibly less, if the query itself yields less rows). LIMIT ALL is the same as omitting the LIMIT clause.

OFFSET says to skip that many rows before beginning to return rows. OFFSET 0 is the same as omitting the OFFSET clause, and LIMIT NULL is the same as omitting the LIMIT clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.

When using LIMIT, it is important to use an ORDER BY clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified ORDER BY.

The query optimizer takes LIMIT into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for LIMIT and OFFSET. Thus, using different LIMIT/OFFSET values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with ORDER BY.

If row_count value is NULL then the query will produce a similar outcome because it does not contain the LIMIT clause.
Or if row_count is zero, the statement will return an empty set.

We can use the OFFSET clause if we want to miss out various of rows before getting the row_count rows.
And the offset clause comes after the LIMIT clause as we can see in the below command:

day9=# select name from taazaatraining order by name limit 6;
      name
----------------
 Gurpreet Singh
 Rahul
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 1;
      name
----------------
 Gurpreet Singh
(1 row)


day9=# select name from taazaatraining order by name limit 2;
      name
----------------
 Gurpreet Singh
 Rahul
(2 rows)


day9=# select name from taazaatraining order by name limit 3;
      name
----------------
 Gurpreet Singh
 Rahul
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 0;
 name
------
(0 rows)


day9=# insert into taazaatraining(name,address,age) values('abhishek','Noida',23);
INSERT 0 1
day9=# select name from taazaatraining order by name limit 2;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)

8.1)  offset with limit

day9=# insert into taazaatraining(name,address,age) values('mohit','Noida',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohan','Noida',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('ram','Noida',23);
INSERT 0 1
day9=# select name from taazaatraining order by name limit 2 offset 0;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)


day9=# select name from taazaatraining order by name limit 3 offset 1;
      name
----------------
 Gurpreet Singh
 mohit
 Rahul
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 2;
 name
-------
 mohit
 Rahul
 ram
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 3;
 name
-------
 Rahul
 ram
 rohan
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 4;
  name
---------
 ram
 rohan
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 5;
  name
---------
 rohan
 sukhdev
(2 rows)


day9=# select name from taazaatraining order by name limit 3 offset 6;
  name
---------
 sukhdev
(1 row)


day9=# select name from taazaatraining order by name limit 3 offset 7;
 name
------
(0 rows)


9) fetch

 the FETCH clause, which is used to recover various rows returned by a command. 
The general syntax of the PostgreSQL FETCH clause is as follows:

OFFSET start { ROW | ROWS }  
FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY  
In the above syntax, we have the following parameters:

Parameter	Description
Start	        It is an integer whose essential value is Positive or Zero; otherwise takes its default value, which is zero.
ROW | ROWS	Here, the Row is the replacement for ROWS, which means the ROW is the alternative for other ROWS; that's why we can use them equivalently.
Row_count	If we do not define the row_count clearly, it will take its default value, which is one.
Note:

If the OFFSET clause is not defined, then the start is larger than the number of rows in the outcome, and no rows are returned as the order of rows kept in that table is unnamed.
If we want to make our software compatible with other database systems, we should use the FETCH clause as it follows the standard SQL, and the FETCH clause is functionally comparable to the LIMIT clause.

day9=# select name from taazaatraining order by name fetch first 2 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)


day9=# select name from taazaatraining order by name fetch first 6 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
(6 rows)


day9=# select name from taazaatraining order by name fetch first 7 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
 sukhdev
(7 rows)


day9=# select name from taazaatraining order by name fetch first 8 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
 sukhdev
(7 rows)


day9=# select name from taazaatraining order by name fetch first  rows only;
   name
----------
 abhishek
(1 row)


day9=# select name from taazaatraining order by name fetch   rows only;
ERROR:  syntax error at or near "rows"
LINE 1: ...ct name from taazaatraining order by name fetch   rows only;
                                                             ^
day9=# select name from taazaatraining order by name fetch  1 rows only;
ERROR:  syntax error at or near "1"
LINE 1: ...ect name from taazaatraining order by name fetch  1 rows onl...
                                                             ^
day9=# select name from taazaatraining order by name fetch second 1 rows only;
ERROR:  syntax error at or near "second"
LINE 1: ...lect name from taazaatraining order by name fetch second 1 r...
                                                             ^
day9=# select name from taazaatraining order by name fetch first 1 rows only;
   name
----------
 abhishek
(1 row)






10) * in

The PostgreSQL IN condition is used within the WHERE clause to get those data that matches any data in a list. In other words, we can say that the IN condition is used to reduce multiple OR conditions.


day9=# insert into taazaatraining(name,address,age) values('rohan','Gurugram',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohan','up',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',20);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',18);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('akash','new delhi',16);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('akash jassal','punjab',14);
INSERT 0 1
day9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where address in ['delhi','noida'];
ERROR:  syntax error at or near "["
LINE 1: select * from taazaatraining where address in ['delhi','noid...
                                                      ^
day9=# select * from taazaatraining where address in ('delhi','noida');
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining where address in ('delhi','Noida');
 id |   name   | address | age
----+----------+---------+-----
  3 | Rahul    | Noida   |  23
  6 | abhishek | Noida   |  23
  7 | mohit    | Noida   |  23
  8 | rohan    | Noida   |  23
  9 | ram      | Noida   |  23
(5 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 15 | akash          | new delhi |  16
(8 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida','up');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(9 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida','up','gurugram');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(9 rows)


day9=# select * from taazaatraining where address not in ('new delhi','Noida','up','gurugram');
 id |     name     |  address   | age
----+--------------+------------+-----
 10 | rohan        | Gurugram   |  23
 12 | rohani       | tamil nadu |  23
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 16 | akash jassal | punjab     |  14
(5 rows)


day9=# select * from taazaatraining where address  in ('new delhi','Noida','up','Gurugram');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 10 | rohan          | Gurugram  |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(10 rows)


11) * like


the working of PostgreSQL Like condition which is used to fetch data using pattern matchings, examples of the like condition by using percent (%), underscore (_) wildcards, Not Like Operator, working of ILIKE operator, and the extension of PostgreSQL Like Operator.

Introduction of PostgreSQL Like condition
The PostgreSQL Like condition is used to fetch data from a table where the defined condition satisfies the LIKE condition. The result contains strings, which are case-sensitive and follow the specified pattern.

In other words, we can also say that the Like condition is used to perform pattern matching for identifying the exact outcome.

To serve the purpose of patterns matching, the PostgreSQL provides two different wildcard characters, which are as follows:


Percent (%) wildcard: To match any sequence of zero or more characters.
Underscore (_) wildcard: To match any single character.

day9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where name=a%;
ERROR:  syntax error at or near ";"
LINE 1: select * from taazaatraining where name=a%;
                                                  ^
day9=# select * from taazaatraining where name='a%';
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining where name='R%';
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining (order by name)  and (name like 'a%');
ERROR:  syntax error at or near "order"
LINE 1: select * from taazaatraining (order by name)  and (name like...
                                      ^
day9=# select * from taazaatraining (name like 'a%');
ERROR:  column "name" does not exist
LINE 1: select * from taazaatraining (name like 'a%');
                                      ^
day9=# select * from taazaatraining where name like 'a%';
 id |     name     |  address  | age
----+--------------+-----------+-----
  6 | abhishek     | Noida     |  23
 15 | akash        | new delhi |  16
 16 | akash jassal | punjab    |  14
(3 rows)

12) AND OR NOT

the AND condition can combine with the SELECT, INSERT, UPDATE, and DELETE commands. In other words, we can say that the AND condition is used to specify the data if all the conditions separated by AND are TRUE.

In PostgreSQL, the OR condition can be combined with the SELECT, INSERT, UPDATE, and DELETE commands to select unique data from various columns in a table. In other words, we can say that the OR condition is used to return the data if any of the conditions divided by OR is TRUE.

The PostgreSQL NOT condition is used with the WHERE clause to negate a condition in a command. The NOT Condition is also knowns as NOT Operator.

ay9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where age>10 and age<20;
 id |     name     |  address   | age
----+--------------+------------+-----
 14 | rohani       | tamil nadu |  18
 15 | akash        | new delhi  |  16
 16 | akash jassal | punjab     |  14
(3 rows)


day9=# select * from taazaatraining where age>20 or age<20;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(13 rows)


day9=# select * from taazaatraining where age>20 or age=20;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
(11 rows)


day9=# select * from taazaatraining where name not like '%h';
 id |     name     |  address   | age
----+--------------+------------+-----
  3 | Rahul        | Noida      |  23
  5 | sukhdev      | new delhi  |  22
  6 | abhishek     | Noida      |  23
  7 | mohit        | Noida      |  23
  8 | rohan        | Noida      |  23
  9 | ram          | Noida      |  23
 10 | rohan        | Gurugram   |  23
 11 | rohan        | up         |  23
 12 | rohani       | tamil nadu |  23
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 16 | akash jassal | punjab     |  14
(12 rows)


day9=#


13) BETWEEN

The PostgreSQL Between condition is used to define how to retrieve values from an expression within a specific range. In other words, we can say that the Between condition is used to match a value against a range of values.

day9=# select * from taazaatraining ;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where age between 10 and 20;
 id |     name     |  address   | age
----+--------------+------------+-----
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 15 | akash        | new delhi  |  16
 16 | akash jassal | punjab     |  14
(4 rows)


day9=#

14) EXIST

In this section, we are going to understand the working of PostgreSQL EXISTS Condition, which is used with the WHERE clause to evaluate the existing rows in a subquery. And we also see examples of EXISTS Condition with different queries such as INSERT, SELECT, NOT EXISTS, NULL, UPDATE, and DELETE.
day9=# select * from taazaatraining where exists (select * from taazaatraining where name like 'r%');
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)



DATE DATATYPE

In PostgreSQL, the Date data type format is YYYY-MM-DD, which helps us to store and insert the date records into the date column.

The Date data type involve 4 bytes of storage size. And the minimum and maximum ranges of date data type start with 4713 BC to 5874897 AD or 1000-01-01 to 9999-12-31.

We can use the CURRENT_DATE after the DEFAULT keyword if we want to use the current date as the column's default value while creating a new table containing a Date column.

smallint DATATYPE

time DATATYPE



day9=# create table student(
day9(# rollno int generated always as identity,
day9(# name varchar(20) not null,
day9(# phno bigint not null,
day9(# age smallint not null,
day9(# fees decimal not null,
day9(# primary key(rollno),
day9(# gender varchar(1) default 'M',
day9(# date_of_admission date not null default current_date,
day9(# dob date not null);
CREATE TABLE
day9=# alter table taazaatraining add time_of_admission time default current_time;
ALTER TABLE
day9=# alter table student add time_of_admission time default current_time;
ALTER TABLE
day9=# insert into student(name,phno,age,fees,gender,dob) values('Mickey',9717983635,22,100.25,'M',1949-09-12);
ERROR:  column "dob" is of type date but expression is of type integer
LINE 1: ...der,dob) values('Mickey',9717983635,22,100.25,'M',1949-09-12...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
day9=# insert into student(name,phno,age,fees,gender,dob) values('Mickey',9717983635,22,100.25,'M','1949-09-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
(1 row)


day9=# insert into student(name,phno,age,fees,dob) values('donal',9733983635,32,200.25,'1939-09-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
      2 | donal  | 9733983635 |  32 | 200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492
(2 rows)


day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,100.25,'F','1949-12-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
      2 | donal  | 9733983635 |  32 | 200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492
      3 | emma   | 9227983635 |  22 | 100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854
(3 rows)


day9=#



char DATATYPE

numeric DATATYPE

day9=# alter table student alter gender type char(1);
ALTER TABLE
day9=# alter table student alter fees type numberic;

day9=# alter table student alter fees type numeric;
ALTER TABLE
day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,10050000000000000000.89,'F','1949-12-12');
INSERT 0 1
day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,10050000000000000000.89,'F','1949-12-12');

25-08-2021(wed) #day 10

postgres=# \c day9
You are now connected to database "day9" as user "postgres".
day9=# create table taazaatraining(
day9(# id int generated always as identity,
day9(# name varchar(50),
day9(# address varchar(50),
day9(# age int);
CREATE TABLE

after lunch
DATE,array,smallint,time,char,numeric DATATYPE


before lunch

1) update


day9=# update taazaatraining set name='das sukhdev' where id=1;
UPDATE 1
day9=# select * from taazaatraining;
 id |    name     |  address  | age
----+-------------+-----------+-----
  2 | sukhdev     | new delhi |  22
  3 | Rahul       | Noida     |  23
  1 | das sukhdev | new delhi |  22
(3 rows)


day9=# update taazaatraining set name='das sukhdev' where id=2;
UPDATE 1
day9=# update taazaatraining set name='Gurpreet singh' where id=1;
UPDATE 1
day9=# select * from taazaatraining;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  2 | das sukhdev    | new delhi |  22
  1 | Gurpreet singh | new delhi |  22
(3 rows)


2) delete
3) where

day9=# delete from taazaatraining where id=2;
DELETE 1
day9=# delete from taazaatraining where id=1;
DELETE 1
day9=# insert into taazaatraining(name,address,age) values('Gurpreet Singh','new delhi',22);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('sukhdev','new delhi',22);
INSERT 0 1
day9=# delete from taazaatraining where id=2;
DELETE 0
day9=# select * from taazaatraining;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
(3 rows)



4) order by

day9=# select * from taazaatraining order by id;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
(3 rows)


day9=# select * from taazaatraining order by address;
 id |      name      |  address  | age
----+----------------+-----------+-----
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  3 | Rahul          | Noida     |  23
(3 rows)


5) * group by
GROUP BY clause in PostgreSQL. We also see examples of how GROUP BY clause working with SUM() function, COUNT(), JOIN clause, multiple columns, and the without an aggregate function.

every group can apply an aggregate function like COUNT() function is used to get the number of items in the groups, and the SUM() function is used to analyze the sum of items.


6) * having

The having clause is used to specify a search condition for a group or an aggregate. And it is regularly used with the GROUP BY clause to filter groups or aggregates based on a detailed condition.


7) distinct

the DISTINCT clause will analyze the matching rows or data according to the grouping of these column's values.

day9=# select address from taazaatraining group by address;
  address
-----------
 new delhi
 Noida
(2 rows)



day9=# select count(address) from taazaatraining group by address having address='new delhi';
 count
-------
     2
(1 row)


day9=# select distinct(address) from taazaatraining ;
  address
-----------
 new delhi
 Noida
(2 rows)


8) limit

LIMIT clause, which is used to get a subset of rows produced by a command.
In the above syntax, Limit clause returns row_count rows created by the command.

If a limit count is given, no more than that many rows will be returned (but possibly less, if the query itself yields less rows). LIMIT ALL is the same as omitting the LIMIT clause.

OFFSET says to skip that many rows before beginning to return rows. OFFSET 0 is the same as omitting the OFFSET clause, and LIMIT NULL is the same as omitting the LIMIT clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.

When using LIMIT, it is important to use an ORDER BY clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified ORDER BY.

The query optimizer takes LIMIT into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for LIMIT and OFFSET. Thus, using different LIMIT/OFFSET values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with ORDER BY.

If row_count value is NULL then the query will produce a similar outcome because it does not contain the LIMIT clause.
Or if row_count is zero, the statement will return an empty set.

We can use the OFFSET clause if we want to miss out various of rows before getting the row_count rows.
And the offset clause comes after the LIMIT clause as we can see in the below command:

day9=# select name from taazaatraining order by name limit 6;
      name
----------------
 Gurpreet Singh
 Rahul
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 1;
      name
----------------
 Gurpreet Singh
(1 row)


day9=# select name from taazaatraining order by name limit 2;
      name
----------------
 Gurpreet Singh
 Rahul
(2 rows)


day9=# select name from taazaatraining order by name limit 3;
      name
----------------
 Gurpreet Singh
 Rahul
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 0;
 name
------
(0 rows)


day9=# insert into taazaatraining(name,address,age) values('abhishek','Noida',23);
INSERT 0 1
day9=# select name from taazaatraining order by name limit 2;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)

8.1)  offset with limit

day9=# insert into taazaatraining(name,address,age) values('mohit','Noida',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohan','Noida',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('ram','Noida',23);
INSERT 0 1
day9=# select name from taazaatraining order by name limit 2 offset 0;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)


day9=# select name from taazaatraining order by name limit 3 offset 1;
      name
----------------
 Gurpreet Singh
 mohit
 Rahul
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 2;
 name
-------
 mohit
 Rahul
 ram
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 3;
 name
-------
 Rahul
 ram
 rohan
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 4;
  name
---------
 ram
 rohan
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 5;
  name
---------
 rohan
 sukhdev
(2 rows)


day9=# select name from taazaatraining order by name limit 3 offset 6;
  name
---------
 sukhdev
(1 row)


day9=# select name from taazaatraining order by name limit 3 offset 7;
 name
------
(0 rows)


9) fetch

 the FETCH clause, which is used to recover various rows returned by a command. 
The general syntax of the PostgreSQL FETCH clause is as follows:

OFFSET start { ROW | ROWS }  
FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY  
In the above syntax, we have the following parameters:

Parameter	Description
Start	        It is an integer whose essential value is Positive or Zero; otherwise takes its default value, which is zero.
ROW | ROWS	Here, the Row is the replacement for ROWS, which means the ROW is the alternative for other ROWS; that's why we can use them equivalently.
Row_count	If we do not define the row_count clearly, it will take its default value, which is one.
Note:

If the OFFSET clause is not defined, then the start is larger than the number of rows in the outcome, and no rows are returned as the order of rows kept in that table is unnamed.
If we want to make our software compatible with other database systems, we should use the FETCH clause as it follows the standard SQL, and the FETCH clause is functionally comparable to the LIMIT clause.

day9=# select name from taazaatraining order by name fetch first 2 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)


day9=# select name from taazaatraining order by name fetch first 6 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
(6 rows)


day9=# select name from taazaatraining order by name fetch first 7 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
 sukhdev
(7 rows)


day9=# select name from taazaatraining order by name fetch first 8 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
 sukhdev
(7 rows)


day9=# select name from taazaatraining order by name fetch first  rows only;
   name
----------
 abhishek
(1 row)


day9=# select name from taazaatraining order by name fetch   rows only;
ERROR:  syntax error at or near "rows"
LINE 1: ...ct name from taazaatraining order by name fetch   rows only;
                                                             ^
day9=# select name from taazaatraining order by name fetch  1 rows only;
ERROR:  syntax error at or near "1"
LINE 1: ...ect name from taazaatraining order by name fetch  1 rows onl...
                                                             ^
day9=# select name from taazaatraining order by name fetch second 1 rows only;
ERROR:  syntax error at or near "second"
LINE 1: ...lect name from taazaatraining order by name fetch second 1 r...
                                                             ^
day9=# select name from taazaatraining order by name fetch first 1 rows only;
   name
----------
 abhishek
(1 row)






10) * in

The PostgreSQL IN condition is used within the WHERE clause to get those data that matches any data in a list. In other words, we can say that the IN condition is used to reduce multiple OR conditions.


day9=# insert into taazaatraining(name,address,age) values('rohan','Gurugram',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohan','up',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',20);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',18);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('akash','new delhi',16);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('akash jassal','punjab',14);
INSERT 0 1
day9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where address in ['delhi','noida'];
ERROR:  syntax error at or near "["
LINE 1: select * from taazaatraining where address in ['delhi','noid...
                                                      ^
day9=# select * from taazaatraining where address in ('delhi','noida');
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining where address in ('delhi','Noida');
 id |   name   | address | age
----+----------+---------+-----
  3 | Rahul    | Noida   |  23
  6 | abhishek | Noida   |  23
  7 | mohit    | Noida   |  23
  8 | rohan    | Noida   |  23
  9 | ram      | Noida   |  23
(5 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 15 | akash          | new delhi |  16
(8 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida','up');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(9 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida','up','gurugram');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(9 rows)


day9=# select * from taazaatraining where address not in ('new delhi','Noida','up','gurugram');
 id |     name     |  address   | age
----+--------------+------------+-----
 10 | rohan        | Gurugram   |  23
 12 | rohani       | tamil nadu |  23
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 16 | akash jassal | punjab     |  14
(5 rows)


day9=# select * from taazaatraining where address  in ('new delhi','Noida','up','Gurugram');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 10 | rohan          | Gurugram  |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(10 rows)


11) * like


the working of PostgreSQL Like condition which is used to fetch data using pattern matchings, examples of the like condition by using percent (%), underscore (_) wildcards, Not Like Operator, working of ILIKE operator, and the extension of PostgreSQL Like Operator.

Introduction of PostgreSQL Like condition
The PostgreSQL Like condition is used to fetch data from a table where the defined condition satisfies the LIKE condition. The result contains strings, which are case-sensitive and follow the specified pattern.

In other words, we can also say that the Like condition is used to perform pattern matching for identifying the exact outcome.

To serve the purpose of patterns matching, the PostgreSQL provides two different wildcard characters, which are as follows:


Percent (%) wildcard: To match any sequence of zero or more characters.
Underscore (_) wildcard: To match any single character.

day9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where name=a%;
ERROR:  syntax error at or near ";"
LINE 1: select * from taazaatraining where name=a%;
                                                  ^
day9=# select * from taazaatraining where name='a%';
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining where name='R%';
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining (order by name)  and (name like 'a%');
ERROR:  syntax error at or near "order"
LINE 1: select * from taazaatraining (order by name)  and (name like...
                                      ^
day9=# select * from taazaatraining (name like 'a%');
ERROR:  column "name" does not exist
LINE 1: select * from taazaatraining (name like 'a%');
                                      ^
day9=# select * from taazaatraining where name like 'a%';
 id |     name     |  address  | age
----+--------------+-----------+-----
  6 | abhishek     | Noida     |  23
 15 | akash        | new delhi |  16
 16 | akash jassal | punjab    |  14
(3 rows)

12) AND OR NOT

the AND condition can combine with the SELECT, INSERT, UPDATE, and DELETE commands. In other words, we can say that the AND condition is used to specify the data if all the conditions separated by AND are TRUE.

In PostgreSQL, the OR condition can be combined with the SELECT, INSERT, UPDATE, and DELETE commands to select unique data from various columns in a table. In other words, we can say that the OR condition is used to return the data if any of the conditions divided by OR is TRUE.

The PostgreSQL NOT condition is used with the WHERE clause to negate a condition in a command. The NOT Condition is also knowns as NOT Operator.

ay9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where age>10 and age<20;
 id |     name     |  address   | age
----+--------------+------------+-----
 14 | rohani       | tamil nadu |  18
 15 | akash        | new delhi  |  16
 16 | akash jassal | punjab     |  14
(3 rows)


day9=# select * from taazaatraining where age>20 or age<20;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(13 rows)


day9=# select * from taazaatraining where age>20 or age=20;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
(11 rows)


day9=# select * from taazaatraining where name not like '%h';
 id |     name     |  address   | age
----+--------------+------------+-----
  3 | Rahul        | Noida      |  23
  5 | sukhdev      | new delhi  |  22
  6 | abhishek     | Noida      |  23
  7 | mohit        | Noida      |  23
  8 | rohan        | Noida      |  23
  9 | ram          | Noida      |  23
 10 | rohan        | Gurugram   |  23
 11 | rohan        | up         |  23
 12 | rohani       | tamil nadu |  23
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 16 | akash jassal | punjab     |  14
(12 rows)


day9=#


13) BETWEEN

The PostgreSQL Between condition is used to define how to retrieve values from an expression within a specific range. In other words, we can say that the Between condition is used to match a value against a range of values.

day9=# select * from taazaatraining ;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where age between 10 and 20;
 id |     name     |  address   | age
----+--------------+------------+-----
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 15 | akash        | new delhi  |  16
 16 | akash jassal | punjab     |  14
(4 rows)


day9=#

14) EXIST

In this section, we are going to understand the working of PostgreSQL EXISTS Condition, which is used with the WHERE clause to evaluate the existing rows in a subquery. And we also see examples of EXISTS Condition with different queries such as INSERT, SELECT, NOT EXISTS, NULL, UPDATE, and DELETE.
day9=# select * from taazaatraining where exists (select * from taazaatraining where name like 'r%');
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)



DATE DATATYPE

In PostgreSQL, the Date data type format is YYYY-MM-DD, which helps us to store and insert the date records into the date column.

The Date data type involve 4 bytes of storage size. And the minimum and maximum ranges of date data type start with 4713 BC to 5874897 AD or 1000-01-01 to 9999-12-31.

We can use the CURRENT_DATE after the DEFAULT keyword if we want to use the current date as the column's default value while creating a new table containing a Date column.

smallint DATATYPE

time DATATYPE



day9=# create table student(
day9(# rollno int generated always as identity,
day9(# name varchar(20) not null,
day9(# phno bigint not null,
day9(# age smallint not null,
day9(# fees decimal not null,
day9(# primary key(rollno),
day9(# gender varchar(1) default 'M',
day9(# date_of_admission date not null default current_date,
day9(# dob date not null);
CREATE TABLE
day9=# alter table taazaatraining add time_of_admission time default current_time;
ALTER TABLE
day9=# alter table student add time_of_admission time default current_time;
ALTER TABLE
day9=# insert into student(name,phno,age,fees,gender,dob) values('Mickey',9717983635,22,100.25,'M',1949-09-12);
ERROR:  column "dob" is of type date but expression is of type integer
LINE 1: ...der,dob) values('Mickey',9717983635,22,100.25,'M',1949-09-12...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
day9=# insert into student(name,phno,age,fees,gender,dob) values('Mickey',9717983635,22,100.25,'M','1949-09-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
(1 row)


day9=# insert into student(name,phno,age,fees,dob) values('donal',9733983635,32,200.25,'1939-09-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
      2 | donal  | 9733983635 |  32 | 200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492
(2 rows)


day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,100.25,'F','1949-12-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
      2 | donal  | 9733983635 |  32 | 200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492
      3 | emma   | 9227983635 |  22 | 100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854
(3 rows)


day9=#



char DATATYPE

numeric DATATYPE

day9=# alter table student alter gender type char(1);
ALTER TABLE
day9=# alter table student alter fees type numberic;

day9=# alter table student alter fees type numeric;
ALTER TABLE
day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,10050000000000000000.89,'F','1949-12-12');
INSERT 0 1
day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,10050000000000000000.89,'F','1949-12-12');


25-08-2021(wed) #day 10

postgres=# \c day9
You are now connected to database "day9" as user "postgres".
day9=# create table taazaatraining(
day9(# id int generated always as identity,
day9(# name varchar(50),
day9(# address varchar(50),
day9(# age int);
CREATE TABLE

after lunch
DATE,array,smallint,time,char,numeric DATATYPE


before lunch

1) update


day9=# update taazaatraining set name='das sukhdev' where id=1;
UPDATE 1
day9=# select * from taazaatraining;
 id |    name     |  address  | age
----+-------------+-----------+-----
  2 | sukhdev     | new delhi |  22
  3 | Rahul       | Noida     |  23
  1 | das sukhdev | new delhi |  22
(3 rows)


day9=# update taazaatraining set name='das sukhdev' where id=2;
UPDATE 1
day9=# update taazaatraining set name='Gurpreet singh' where id=1;
UPDATE 1
day9=# select * from taazaatraining;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  2 | das sukhdev    | new delhi |  22
  1 | Gurpreet singh | new delhi |  22
(3 rows)


2) delete
3) where

day9=# delete from taazaatraining where id=2;
DELETE 1
day9=# delete from taazaatraining where id=1;
DELETE 1
day9=# insert into taazaatraining(name,address,age) values('Gurpreet Singh','new delhi',22);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('sukhdev','new delhi',22);
INSERT 0 1
day9=# delete from taazaatraining where id=2;
DELETE 0
day9=# select * from taazaatraining;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
(3 rows)



4) order by

day9=# select * from taazaatraining order by id;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
(3 rows)


day9=# select * from taazaatraining order by address;
 id |      name      |  address  | age
----+----------------+-----------+-----
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  3 | Rahul          | Noida     |  23
(3 rows)


5) * group by
GROUP BY clause in PostgreSQL. We also see examples of how GROUP BY clause working with SUM() function, COUNT(), JOIN clause, multiple columns, and the without an aggregate function.

every group can apply an aggregate function like COUNT() function is used to get the number of items in the groups, and the SUM() function is used to analyze the sum of items.


6) * having

The having clause is used to specify a search condition for a group or an aggregate. And it is regularly used with the GROUP BY clause to filter groups or aggregates based on a detailed condition.


7) distinct

the DISTINCT clause will analyze the matching rows or data according to the grouping of these column's values.

day9=# select address from taazaatraining group by address;
  address
-----------
 new delhi
 Noida
(2 rows)



day9=# select count(address) from taazaatraining group by address having address='new delhi';
 count
-------
     2
(1 row)


day9=# select distinct(address) from taazaatraining ;
  address
-----------
 new delhi
 Noida
(2 rows)


8) limit

LIMIT clause, which is used to get a subset of rows produced by a command.
In the above syntax, Limit clause returns row_count rows created by the command.

If a limit count is given, no more than that many rows will be returned (but possibly less, if the query itself yields less rows). LIMIT ALL is the same as omitting the LIMIT clause.

OFFSET says to skip that many rows before beginning to return rows. OFFSET 0 is the same as omitting the OFFSET clause, and LIMIT NULL is the same as omitting the LIMIT clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.

When using LIMIT, it is important to use an ORDER BY clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified ORDER BY.

The query optimizer takes LIMIT into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for LIMIT and OFFSET. Thus, using different LIMIT/OFFSET values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with ORDER BY.

If row_count value is NULL then the query will produce a similar outcome because it does not contain the LIMIT clause.
Or if row_count is zero, the statement will return an empty set.

We can use the OFFSET clause if we want to miss out various of rows before getting the row_count rows.
And the offset clause comes after the LIMIT clause as we can see in the below command:

day9=# select name from taazaatraining order by name limit 6;
      name
----------------
 Gurpreet Singh
 Rahul
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 1;
      name
----------------
 Gurpreet Singh
(1 row)


day9=# select name from taazaatraining order by name limit 2;
      name
----------------
 Gurpreet Singh
 Rahul
(2 rows)


day9=# select name from taazaatraining order by name limit 3;
      name
----------------
 Gurpreet Singh
 Rahul
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 0;
 name
------
(0 rows)


day9=# insert into taazaatraining(name,address,age) values('abhishek','Noida',23);
INSERT 0 1
day9=# select name from taazaatraining order by name limit 2;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)

8.1)  offset with limit

day9=# insert into taazaatraining(name,address,age) values('mohit','Noida',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohan','Noida',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('ram','Noida',23);
INSERT 0 1
day9=# select name from taazaatraining order by name limit 2 offset 0;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)


day9=# select name from taazaatraining order by name limit 3 offset 1;
      name
----------------
 Gurpreet Singh
 mohit
 Rahul
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 2;
 name
-------
 mohit
 Rahul
 ram
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 3;
 name
-------
 Rahul
 ram
 rohan
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 4;
  name
---------
 ram
 rohan
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 5;
  name
---------
 rohan
 sukhdev
(2 rows)


day9=# select name from taazaatraining order by name limit 3 offset 6;
  name
---------
 sukhdev
(1 row)


day9=# select name from taazaatraining order by name limit 3 offset 7;
 name
------
(0 rows)


9) fetch

 the FETCH clause, which is used to recover various rows returned by a command. 
The general syntax of the PostgreSQL FETCH clause is as follows:

OFFSET start { ROW | ROWS }  
FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY  
In the above syntax, we have the following parameters:

Parameter	Description
Start	        It is an integer whose essential value is Positive or Zero; otherwise takes its default value, which is zero.
ROW | ROWS	Here, the Row is the replacement for ROWS, which means the ROW is the alternative for other ROWS; that's why we can use them equivalently.
Row_count	If we do not define the row_count clearly, it will take its default value, which is one.
Note:

If the OFFSET clause is not defined, then the start is larger than the number of rows in the outcome, and no rows are returned as the order of rows kept in that table is unnamed.
If we want to make our software compatible with other database systems, we should use the FETCH clause as it follows the standard SQL, and the FETCH clause is functionally comparable to the LIMIT clause.

day9=# select name from taazaatraining order by name fetch first 2 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)


day9=# select name from taazaatraining order by name fetch first 6 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
(6 rows)


day9=# select name from taazaatraining order by name fetch first 7 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
 sukhdev
(7 rows)


day9=# select name from taazaatraining order by name fetch first 8 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
 sukhdev
(7 rows)


day9=# select name from taazaatraining order by name fetch first  rows only;
   name
----------
 abhishek
(1 row)


day9=# select name from taazaatraining order by name fetch   rows only;
ERROR:  syntax error at or near "rows"
LINE 1: ...ct name from taazaatraining order by name fetch   rows only;
                                                             ^
day9=# select name from taazaatraining order by name fetch  1 rows only;
ERROR:  syntax error at or near "1"
LINE 1: ...ect name from taazaatraining order by name fetch  1 rows onl...
                                                             ^
day9=# select name from taazaatraining order by name fetch second 1 rows only;
ERROR:  syntax error at or near "second"
LINE 1: ...lect name from taazaatraining order by name fetch second 1 r...
                                                             ^
day9=# select name from taazaatraining order by name fetch first 1 rows only;
   name
----------
 abhishek
(1 row)






10) * in

The PostgreSQL IN condition is used within the WHERE clause to get those data that matches any data in a list. In other words, we can say that the IN condition is used to reduce multiple OR conditions.


day9=# insert into taazaatraining(name,address,age) values('rohan','Gurugram',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohan','up',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',20);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',18);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('akash','new delhi',16);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('akash jassal','punjab',14);
INSERT 0 1
day9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where address in ['delhi','noida'];
ERROR:  syntax error at or near "["
LINE 1: select * from taazaatraining where address in ['delhi','noid...
                                                      ^
day9=# select * from taazaatraining where address in ('delhi','noida');
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining where address in ('delhi','Noida');
 id |   name   | address | age
----+----------+---------+-----
  3 | Rahul    | Noida   |  23
  6 | abhishek | Noida   |  23
  7 | mohit    | Noida   |  23
  8 | rohan    | Noida   |  23
  9 | ram      | Noida   |  23
(5 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 15 | akash          | new delhi |  16
(8 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida','up');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(9 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida','up','gurugram');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(9 rows)


day9=# select * from taazaatraining where address not in ('new delhi','Noida','up','gurugram');
 id |     name     |  address   | age
----+--------------+------------+-----
 10 | rohan        | Gurugram   |  23
 12 | rohani       | tamil nadu |  23
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 16 | akash jassal | punjab     |  14
(5 rows)


day9=# select * from taazaatraining where address  in ('new delhi','Noida','up','Gurugram');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 10 | rohan          | Gurugram  |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(10 rows)


11) * like


the working of PostgreSQL Like condition which is used to fetch data using pattern matchings, examples of the like condition by using percent (%), underscore (_) wildcards, Not Like Operator, working of ILIKE operator, and the extension of PostgreSQL Like Operator.

Introduction of PostgreSQL Like condition
The PostgreSQL Like condition is used to fetch data from a table where the defined condition satisfies the LIKE condition. The result contains strings, which are case-sensitive and follow the specified pattern.

In other words, we can also say that the Like condition is used to perform pattern matching for identifying the exact outcome.

To serve the purpose of patterns matching, the PostgreSQL provides two different wildcard characters, which are as follows:


Percent (%) wildcard: To match any sequence of zero or more characters.
Underscore (_) wildcard: To match any single character.

day9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where name=a%;
ERROR:  syntax error at or near ";"
LINE 1: select * from taazaatraining where name=a%;
                                                  ^
day9=# select * from taazaatraining where name='a%';
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining where name='R%';
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining (order by name)  and (name like 'a%');
ERROR:  syntax error at or near "order"
LINE 1: select * from taazaatraining (order by name)  and (name like...
                                      ^
day9=# select * from taazaatraining (name like 'a%');
ERROR:  column "name" does not exist
LINE 1: select * from taazaatraining (name like 'a%');
                                      ^
day9=# select * from taazaatraining where name like 'a%';
 id |     name     |  address  | age
----+--------------+-----------+-----
  6 | abhishek     | Noida     |  23
 15 | akash        | new delhi |  16
 16 | akash jassal | punjab    |  14
(3 rows)

12) AND OR NOT

the AND condition can combine with the SELECT, INSERT, UPDATE, and DELETE commands. In other words, we can say that the AND condition is used to specify the data if all the conditions separated by AND are TRUE.

In PostgreSQL, the OR condition can be combined with the SELECT, INSERT, UPDATE, and DELETE commands to select unique data from various columns in a table. In other words, we can say that the OR condition is used to return the data if any of the conditions divided by OR is TRUE.

The PostgreSQL NOT condition is used with the WHERE clause to negate a condition in a command. The NOT Condition is also knowns as NOT Operator.

ay9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where age>10 and age<20;
 id |     name     |  address   | age
----+--------------+------------+-----
 14 | rohani       | tamil nadu |  18
 15 | akash        | new delhi  |  16
 16 | akash jassal | punjab     |  14
(3 rows)


day9=# select * from taazaatraining where age>20 or age<20;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(13 rows)


day9=# select * from taazaatraining where age>20 or age=20;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
(11 rows)


day9=# select * from taazaatraining where name not like '%h';
 id |     name     |  address   | age
----+--------------+------------+-----
  3 | Rahul        | Noida      |  23
  5 | sukhdev      | new delhi  |  22
  6 | abhishek     | Noida      |  23
  7 | mohit        | Noida      |  23
  8 | rohan        | Noida      |  23
  9 | ram          | Noida      |  23
 10 | rohan        | Gurugram   |  23
 11 | rohan        | up         |  23
 12 | rohani       | tamil nadu |  23
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 16 | akash jassal | punjab     |  14
(12 rows)


day9=#


13) BETWEEN

The PostgreSQL Between condition is used to define how to retrieve values from an expression within a specific range. In other words, we can say that the Between condition is used to match a value against a range of values.

day9=# select * from taazaatraining ;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where age between 10 and 20;
 id |     name     |  address   | age
----+--------------+------------+-----
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 15 | akash        | new delhi  |  16
 16 | akash jassal | punjab     |  14
(4 rows)


day9=#

14) EXIST

In this section, we are going to understand the working of PostgreSQL EXISTS Condition, which is used with the WHERE clause to evaluate the existing rows in a subquery. And we also see examples of EXISTS Condition with different queries such as INSERT, SELECT, NOT EXISTS, NULL, UPDATE, and DELETE.
day9=# select * from taazaatraining where exists (select * from taazaatraining where name like 'r%');
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)



DATE DATATYPE

In PostgreSQL, the Date data type format is YYYY-MM-DD, which helps us to store and insert the date records into the date column.

The Date data type involve 4 bytes of storage size. And the minimum and maximum ranges of date data type start with 4713 BC to 5874897 AD or 1000-01-01 to 9999-12-31.

We can use the CURRENT_DATE after the DEFAULT keyword if we want to use the current date as the column's default value while creating a new table containing a Date column.

smallint DATATYPE

time DATATYPE



day9=# create table student(
day9(# rollno int generated always as identity,
day9(# name varchar(20) not null,
day9(# phno bigint not null,
day9(# age smallint not null,
day9(# fees decimal not null,
day9(# primary key(rollno),
day9(# gender varchar(1) default 'M',
day9(# date_of_admission date not null default current_date,
day9(# dob date not null);
CREATE TABLE
day9=# alter table taazaatraining add time_of_admission time default current_time;
ALTER TABLE
day9=# alter table student add time_of_admission time default current_time;
ALTER TABLE
day9=# insert into student(name,phno,age,fees,gender,dob) values('Mickey',9717983635,22,100.25,'M',1949-09-12);
ERROR:  column "dob" is of type date but expression is of type integer
LINE 1: ...der,dob) values('Mickey',9717983635,22,100.25,'M',1949-09-12...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
day9=# insert into student(name,phno,age,fees,gender,dob) values('Mickey',9717983635,22,100.25,'M','1949-09-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
(1 row)


day9=# insert into student(name,phno,age,fees,dob) values('donal',9733983635,32,200.25,'1939-09-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
      2 | donal  | 9733983635 |  32 | 200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492
(2 rows)


day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,100.25,'F','1949-12-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
      2 | donal  | 9733983635 |  32 | 200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492
      3 | emma   | 9227983635 |  22 | 100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854
(3 rows)


day9=#



char DATATYPE

numeric DATATYPE

day9=# alter table student alter gender type char(1);
ALTER TABLE
day9=# alter table student alter fees type numberic;

day9=# alter table student alter fees type numeric;
ALTER TABLE
day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,10050000000000000000.89,'F','1949-12-12');
INSERT 0 1
day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,10050000000000000000.89,'F','1949-12-12');



