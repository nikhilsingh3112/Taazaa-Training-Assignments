24-08-2021 work

Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Password for user postgres:
psql (13.4)
WARNING: Console code page (437) differs from Windows code page (1252)
         8-bit characters might not work correctly. See psql reference
         page "Notes for Windows users" for details.
Type "help" for help.

#how to connect with db

postgres=# create database Gurpreet_Singh
postgres-# ;
CREATE DATABASE
postgres=# \l
                                                   List of databases
      Name      |  Owner   | Encoding |          Collate           |           Ctype            |   Access privileges   ----------------+----------+----------+----------------------------+----------------------------+----------------------- day9           | postgres | UTF8     | English_United States.1252 | English_United States.1252 |
 dbname         | postgres | UTF8     | English_United States.1252 | English_United States.1252 |
 gurpreet       | postgres | UTF8     | English_United States.1252 | English_United States.1252 |
 gurpreet_singh | postgres | UTF8     | English_United States.1252 | English_United States.1252 |
 mickey         | postgres | UTF8     | English_United States.1252 | English_United States.1252 |
 postgres       | postgres | UTF8     | English_United States.1252 | English_United States.1252 |
 template0      | postgres | UTF8     | English_United States.1252 | English_United States.1252 | =c/postgres          +                |          |          |                            |                            | postgres=CTc/postgres
 template1      | postgres | UTF8     | English_United States.1252 | English_United States.1252 | =c/postgres          +                |          |          |                            |                            | postgres=CTc/postgres
(8 rows)

#howto connect with db

postgres=# \c gurpreet_singh;
You are now connected to database "gurpreet_singh" as user "postgres".

# how to check for the table available in db

gurpreet_singh=# \d
Did not find any relations.
how to create table with primary key, date & time dataype

gurpreet_singh=# create table employee(
gurpreet_singh(# emp_id int generated always as identity,
gurpreet_singh(# primary key(emp_id),
gurpreet_singh(# e_name varchar(20) not null,
gurpreet_singh(# age char(1) not null,
gurpreet_singh(# gender char(1) default 'M',
gurpreet_singh(# jdate date default current_date,
gurpreet_singh(# tdate time default current_time);
CREATE TABLE
gurpreet_singh=# \d
                 List of relations
 Schema |        Name         |   Type   |  Owner
--------+---------------------+----------+----------
 public | employee            | table    | postgres
 public | employee_emp_id_seq | sequence | postgres
(2 rows)

how to create table with foreign key

gurpreet_singh=# create table department(
gurpreet_singh(# dept_id int generated always as identity,
gurpreet_singh(# dept_name varchar(30) not null,
gurpreet_singh(# primary key(dept_id),
gurpreet_singh(# emp_id int not null,
gurpreet_singh(# constraint fkdept foreign key(emp_id) references employee(emp_id));
CREATE TABLE
gurpreet_singh=# \d
                   List of relations
 Schema |          Name          |   Type   |  Owner
--------+------------------------+----------+----------
 public | department             | table    | postgres
 public | department_dept_id_seq | sequence | postgres
 public | employee               | table    | postgres
 public | employee_emp_id_seq    | sequence | postgres
(4 rows)

# how to use alter command

gurpreet_singh=# alter table employee alter column age type char(2);
ALTER TABLE

Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Password for user postgres:
psql (13.4)
WARNING: Console code page (437) differs from Windows code page (1252)
         8-bit characters might not work correctly. See psql reference
         page "Notes for Windows users" for details.
Type "help" for help.

postgres=# \c gurpreet_singh
You are now connected to database "gurpreet_singh" as user "postgres".
                             ^
# how to insert values in table

gurpreet_singh=# insert into employee(e_name,age) values('Gurpreet Singh','22');
INSERT 0 1
gurpreet_singh=# insert into employee(e_name,age) values('Harpreet Singh','23');
INSERT 0 1
gurpreet_singh=# insert into employee(e_name,age) values('Rahul ','23');
INSERT 0 1
gurpreet_singh=# insert into employee(e_name,age) values('Rohit ','23');
INSERT 0 1
gurpreet_singh=# insert into employee(e_name,age) values('Mohit ','23');
INSERT 0 1
gurpreet_singh=# insert into employee(e_name,age) values('Saurabh ','23');
INSERT 0 1
gurpreet_singh=# insert into employee(e_name,age,gender) values('Jyoti ','23','F');
INSERT 0 1
gurpreet_singh=# select * from employee
gurpreet_singh-# ;
 emp_id |     e_name     | age | gender |   jdate    |      tdate
--------+----------------+-----+--------+------------+-----------------
      1 | Gurpreet Singh | 22  | M      | 2021-08-27 | 09:14:29.424046
      2 | Harpreet Singh | 23  | M      | 2021-08-27 | 09:14:48.579051
      3 | Rahul          | 23  | M      | 2021-08-27 | 09:15:04.299688
      4 | Rohit          | 23  | M      | 2021-08-27 | 09:15:13.90208
      5 | Mohit          | 23  | M      | 2021-08-27 | 09:15:29.931416
      6 | Saurabh        | 23  | M      | 2021-08-27 | 09:15:40.679304
      7 | Jyoti          | 23  | F      | 2021-08-27 | 09:16:12.308645
(7 rows)


gurpreet_singh=# insert into department(dept_name,emp_id) values('cse',2);
INSERT 0 1
gurpreet_singh=# insert into department(dept_name,emp_id) values('it',1);
INSERT 0 1
gurpreet_singh=# insert into department(dept_name,emp_id) values('it',3);
INSERT 0 1
gurpreet_singh=# insert into department(dept_name,emp_id) values('cse',4);
INSERT 0 1
gurpreet_singh=# insert into department(dept_name,emp_id) values('ECE',5);
INSERT 0 1
gurpreet_singh=# insert into department(dept_name,emp_id) values('EEE',6);
INSERT 0 1
gurpreet_singh=# insert into department(dept_name,emp_id) values('ME',7);
INSERT 0 1
gurpreet_singh=# select * from department;
 dept_id | dept_name | emp_id
---------+-----------+--------
       1 | cse       |      2
       2 | it        |      1
       3 | it        |      3
       4 | cse       |      4
       5 | ECE       |      5
       6 | EEE       |      6
       7 | ME        |      7
(7 rows)


gurpreet_singh=# select s.emp_id,e_name,dept_name from employee s,department d where s.emp_id=d.emp_id;
 emp_id |     e_name     | dept_name
--------+----------------+-----------
      2 | Harpreet Singh | cse
      1 | Gurpreet Singh | it
      3 | Rahul          | it
      4 | Rohit          | cse
      5 | Mohit          | ECE
      6 | Saurabh        | EEE
      7 | Jyoti          | ME
(7 rows)


gurpreet_singh=#

#   how to drop table in sql

gurpreet_singh=# create table dublicate as select * from department;
SELECT 7
gurpreet_singh=# select * from dublicate;
 dept_id | dept_name | emp_id
---------+-----------+--------
       1 | cse       |      2
       2 | it        |      1
       3 | it        |      3
       4 | cse       |      4
       5 | ECE       |      5
       6 | EEE       |      6
       7 | ME        |      7
(7 rows)


gurpreet_singh=# drop table dublicate;
DROP TABLE
gurpreet_singh=# \d
                   List of relations
 Schema |          Name          |   Type   |  Owner
--------+------------------------+----------+----------
 public | department             | table    | postgres
 public | department_dept_id_seq | sequence | postgres
 public | employee               | table    | postgres
 public | employee_emp_id_seq    | sequence | postgres
(4 rows)


25-08-2021(wed) #day 10

postgres=# \c day9
You are now connected to database "day9" as user "postgres".
day9=# create table taazaatraining(
day9(# id int generated always as identity,
day9(# name varchar(50),
day9(# address varchar(50),
day9(# age int);
CREATE TABLE

after lunch
DATE,array,smallint,time,char,numeric DATATYPE


before lunch

1) update


day9=# update taazaatraining set name='das sukhdev' where id=1;
UPDATE 1
day9=# select * from taazaatraining;
 id |    name     |  address  | age
----+-------------+-----------+-----
  2 | sukhdev     | new delhi |  22
  3 | Rahul       | Noida     |  23
  1 | das sukhdev | new delhi |  22
(3 rows)


day9=# update taazaatraining set name='das sukhdev' where id=2;
UPDATE 1
day9=# update taazaatraining set name='Gurpreet singh' where id=1;
UPDATE 1
day9=# select * from taazaatraining;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  2 | das sukhdev    | new delhi |  22
  1 | Gurpreet singh | new delhi |  22
(3 rows)


2) delete
3) where

day9=# delete from taazaatraining where id=2;
DELETE 1
day9=# delete from taazaatraining where id=1;
DELETE 1
day9=# insert into taazaatraining(name,address,age) values('Gurpreet Singh','new delhi',22);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('sukhdev','new delhi',22);
INSERT 0 1
day9=# delete from taazaatraining where id=2;
DELETE 0
day9=# select * from taazaatraining;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
(3 rows)



4) order by

day9=# select * from taazaatraining order by id;
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
(3 rows)


day9=# select * from taazaatraining order by address;
 id |      name      |  address  | age
----+----------------+-----------+-----
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  3 | Rahul          | Noida     |  23
(3 rows)


5) * group by
GROUP BY clause in PostgreSQL. We also see examples of how GROUP BY clause working with SUM() function, COUNT(), JOIN clause, multiple columns, and the without an aggregate function.

every group can apply an aggregate function like COUNT() function is used to get the number of items in the groups, and the SUM() function is used to analyze the sum of items.


6) * having

The having clause is used to specify a search condition for a group or an aggregate. And it is regularly used with the GROUP BY clause to filter groups or aggregates based on a detailed condition.


7) distinct

the DISTINCT clause will analyze the matching rows or data according to the grouping of these column's values.

day9=# select address from taazaatraining group by address;
  address
-----------
 new delhi
 Noida
(2 rows)



day9=# select count(address) from taazaatraining group by address having address='new delhi';
 count
-------
     2
(1 row)


day9=# select distinct(address) from taazaatraining ;
  address
-----------
 new delhi
 Noida
(2 rows)


8) limit

LIMIT clause, which is used to get a subset of rows produced by a command.
In the above syntax, Limit clause returns row_count rows created by the command.

If a limit count is given, no more than that many rows will be returned (but possibly less, if the query itself yields less rows). LIMIT ALL is the same as omitting the LIMIT clause.

OFFSET says to skip that many rows before beginning to return rows. OFFSET 0 is the same as omitting the OFFSET clause, and LIMIT NULL is the same as omitting the LIMIT clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.

When using LIMIT, it is important to use an ORDER BY clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified ORDER BY.

The query optimizer takes LIMIT into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for LIMIT and OFFSET. Thus, using different LIMIT/OFFSET values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with ORDER BY.

If row_count value is NULL then the query will produce a similar outcome because it does not contain the LIMIT clause.
Or if row_count is zero, the statement will return an empty set.

We can use the OFFSET clause if we want to miss out various of rows before getting the row_count rows.
And the offset clause comes after the LIMIT clause as we can see in the below command:

day9=# select name from taazaatraining order by name limit 6;
      name
----------------
 Gurpreet Singh
 Rahul
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 1;
      name
----------------
 Gurpreet Singh
(1 row)


day9=# select name from taazaatraining order by name limit 2;
      name
----------------
 Gurpreet Singh
 Rahul
(2 rows)


day9=# select name from taazaatraining order by name limit 3;
      name
----------------
 Gurpreet Singh
 Rahul
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 0;
 name
------
(0 rows)


day9=# insert into taazaatraining(name,address,age) values('abhishek','Noida',23);
INSERT 0 1
day9=# select name from taazaatraining order by name limit 2;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)

8.1)  offset with limit

day9=# insert into taazaatraining(name,address,age) values('mohit','Noida',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohan','Noida',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('ram','Noida',23);
INSERT 0 1
day9=# select name from taazaatraining order by name limit 2 offset 0;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)


day9=# select name from taazaatraining order by name limit 3 offset 1;
      name
----------------
 Gurpreet Singh
 mohit
 Rahul
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 2;
 name
-------
 mohit
 Rahul
 ram
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 3;
 name
-------
 Rahul
 ram
 rohan
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 4;
  name
---------
 ram
 rohan
 sukhdev
(3 rows)


day9=# select name from taazaatraining order by name limit 3 offset 5;
  name
---------
 rohan
 sukhdev
(2 rows)


day9=# select name from taazaatraining order by name limit 3 offset 6;
  name
---------
 sukhdev
(1 row)


day9=# select name from taazaatraining order by name limit 3 offset 7;
 name
------
(0 rows)


9) fetch

 the FETCH clause, which is used to recover various rows returned by a command. 
The general syntax of the PostgreSQL FETCH clause is as follows:

OFFSET start { ROW | ROWS }  
FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY  
In the above syntax, we have the following parameters:

Parameter	Description
Start	        It is an integer whose essential value is Positive or Zero; otherwise takes its default value, which is zero.
ROW | ROWS	Here, the Row is the replacement for ROWS, which means the ROW is the alternative for other ROWS; that's why we can use them equivalently.
Row_count	If we do not define the row_count clearly, it will take its default value, which is one.
Note:

If the OFFSET clause is not defined, then the start is larger than the number of rows in the outcome, and no rows are returned as the order of rows kept in that table is unnamed.
If we want to make our software compatible with other database systems, we should use the FETCH clause as it follows the standard SQL, and the FETCH clause is functionally comparable to the LIMIT clause.

day9=# select name from taazaatraining order by name fetch first 2 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
(2 rows)


day9=# select name from taazaatraining order by name fetch first 6 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
(6 rows)


day9=# select name from taazaatraining order by name fetch first 7 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
 sukhdev
(7 rows)


day9=# select name from taazaatraining order by name fetch first 8 rows only;
      name
----------------
 abhishek
 Gurpreet Singh
 mohit
 Rahul
 ram
 rohan
 sukhdev
(7 rows)


day9=# select name from taazaatraining order by name fetch first  rows only;
   name
----------
 abhishek
(1 row)


day9=# select name from taazaatraining order by name fetch   rows only;
ERROR:  syntax error at or near "rows"
LINE 1: ...ct name from taazaatraining order by name fetch   rows only;
                                                             ^
day9=# select name from taazaatraining order by name fetch  1 rows only;
ERROR:  syntax error at or near "1"
LINE 1: ...ect name from taazaatraining order by name fetch  1 rows onl...
                                                             ^
day9=# select name from taazaatraining order by name fetch second 1 rows only;
ERROR:  syntax error at or near "second"
LINE 1: ...lect name from taazaatraining order by name fetch second 1 r...
                                                             ^
day9=# select name from taazaatraining order by name fetch first 1 rows only;
   name
----------
 abhishek
(1 row)






10) * in

The PostgreSQL IN condition is used within the WHERE clause to get those data that matches any data in a list. In other words, we can say that the IN condition is used to reduce multiple OR conditions.


day9=# insert into taazaatraining(name,address,age) values('rohan','Gurugram',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohan','up',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',23);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',20);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('rohani','tamil nadu',18);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('akash','new delhi',16);
INSERT 0 1
day9=# insert into taazaatraining(name,address,age) values('akash jassal','punjab',14);
INSERT 0 1
day9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where address in ['delhi','noida'];
ERROR:  syntax error at or near "["
LINE 1: select * from taazaatraining where address in ['delhi','noid...
                                                      ^
day9=# select * from taazaatraining where address in ('delhi','noida');
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining where address in ('delhi','Noida');
 id |   name   | address | age
----+----------+---------+-----
  3 | Rahul    | Noida   |  23
  6 | abhishek | Noida   |  23
  7 | mohit    | Noida   |  23
  8 | rohan    | Noida   |  23
  9 | ram      | Noida   |  23
(5 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 15 | akash          | new delhi |  16
(8 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida','up');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(9 rows)


day9=# select * from taazaatraining where address in ('new delhi','Noida','up','gurugram');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(9 rows)


day9=# select * from taazaatraining where address not in ('new delhi','Noida','up','gurugram');
 id |     name     |  address   | age
----+--------------+------------+-----
 10 | rohan        | Gurugram   |  23
 12 | rohani       | tamil nadu |  23
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 16 | akash jassal | punjab     |  14
(5 rows)


day9=# select * from taazaatraining where address  in ('new delhi','Noida','up','Gurugram');
 id |      name      |  address  | age
----+----------------+-----------+-----
  3 | Rahul          | Noida     |  23
  4 | Gurpreet Singh | new delhi |  22
  5 | sukhdev        | new delhi |  22
  6 | abhishek       | Noida     |  23
  7 | mohit          | Noida     |  23
  8 | rohan          | Noida     |  23
  9 | ram            | Noida     |  23
 10 | rohan          | Gurugram  |  23
 11 | rohan          | up        |  23
 15 | akash          | new delhi |  16
(10 rows)


11) * like


the working of PostgreSQL Like condition which is used to fetch data using pattern matchings, examples of the like condition by using percent (%), underscore (_) wildcards, Not Like Operator, working of ILIKE operator, and the extension of PostgreSQL Like Operator.

Introduction of PostgreSQL Like condition
The PostgreSQL Like condition is used to fetch data from a table where the defined condition satisfies the LIKE condition. The result contains strings, which are case-sensitive and follow the specified pattern.

In other words, we can also say that the Like condition is used to perform pattern matching for identifying the exact outcome.

To serve the purpose of patterns matching, the PostgreSQL provides two different wildcard characters, which are as follows:


Percent (%) wildcard: To match any sequence of zero or more characters.
Underscore (_) wildcard: To match any single character.

day9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where name=a%;
ERROR:  syntax error at or near ";"
LINE 1: select * from taazaatraining where name=a%;
                                                  ^
day9=# select * from taazaatraining where name='a%';
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining where name='R%';
 id | name | address | age
----+------+---------+-----
(0 rows)


day9=# select * from taazaatraining (order by name)  and (name like 'a%');
ERROR:  syntax error at or near "order"
LINE 1: select * from taazaatraining (order by name)  and (name like...
                                      ^
day9=# select * from taazaatraining (name like 'a%');
ERROR:  column "name" does not exist
LINE 1: select * from taazaatraining (name like 'a%');
                                      ^
day9=# select * from taazaatraining where name like 'a%';
 id |     name     |  address  | age
----+--------------+-----------+-----
  6 | abhishek     | Noida     |  23
 15 | akash        | new delhi |  16
 16 | akash jassal | punjab    |  14
(3 rows)

12) AND OR NOT

the AND condition can combine with the SELECT, INSERT, UPDATE, and DELETE commands. In other words, we can say that the AND condition is used to specify the data if all the conditions separated by AND are TRUE.

In PostgreSQL, the OR condition can be combined with the SELECT, INSERT, UPDATE, and DELETE commands to select unique data from various columns in a table. In other words, we can say that the OR condition is used to return the data if any of the conditions divided by OR is TRUE.

The PostgreSQL NOT condition is used with the WHERE clause to negate a condition in a command. The NOT Condition is also knowns as NOT Operator.

ay9=# select * from taazaatraining;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where age>10 and age<20;
 id |     name     |  address   | age
----+--------------+------------+-----
 14 | rohani       | tamil nadu |  18
 15 | akash        | new delhi  |  16
 16 | akash jassal | punjab     |  14
(3 rows)


day9=# select * from taazaatraining where age>20 or age<20;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(13 rows)


day9=# select * from taazaatraining where age>20 or age=20;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
(11 rows)


day9=# select * from taazaatraining where name not like '%h';
 id |     name     |  address   | age
----+--------------+------------+-----
  3 | Rahul        | Noida      |  23
  5 | sukhdev      | new delhi  |  22
  6 | abhishek     | Noida      |  23
  7 | mohit        | Noida      |  23
  8 | rohan        | Noida      |  23
  9 | ram          | Noida      |  23
 10 | rohan        | Gurugram   |  23
 11 | rohan        | up         |  23
 12 | rohani       | tamil nadu |  23
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 16 | akash jassal | punjab     |  14
(12 rows)


day9=#


13) BETWEEN

The PostgreSQL Between condition is used to define how to retrieve values from an expression within a specific range. In other words, we can say that the Between condition is used to match a value against a range of values.

day9=# select * from taazaatraining ;
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)


day9=# select * from taazaatraining where age between 10 and 20;
 id |     name     |  address   | age
----+--------------+------------+-----
 13 | rohani       | tamil nadu |  20
 14 | rohani       | tamil nadu |  18
 15 | akash        | new delhi  |  16
 16 | akash jassal | punjab     |  14
(4 rows)


day9=#

14) EXIST

In this section, we are going to understand the working of PostgreSQL EXISTS Condition, which is used with the WHERE clause to evaluate the existing rows in a subquery. And we also see examples of EXISTS Condition with different queries such as INSERT, SELECT, NOT EXISTS, NULL, UPDATE, and DELETE.
day9=# select * from taazaatraining where exists (select * from taazaatraining where name like 'r%');
 id |      name      |  address   | age
----+----------------+------------+-----
  3 | Rahul          | Noida      |  23
  4 | Gurpreet Singh | new delhi  |  22
  5 | sukhdev        | new delhi  |  22
  6 | abhishek       | Noida      |  23
  7 | mohit          | Noida      |  23
  8 | rohan          | Noida      |  23
  9 | ram            | Noida      |  23
 10 | rohan          | Gurugram   |  23
 11 | rohan          | up         |  23
 12 | rohani         | tamil nadu |  23
 13 | rohani         | tamil nadu |  20
 14 | rohani         | tamil nadu |  18
 15 | akash          | new delhi  |  16
 16 | akash jassal   | punjab     |  14
(14 rows)



DATE DATATYPE

In PostgreSQL, the Date data type format is YYYY-MM-DD, which helps us to store and insert the date records into the date column.

The Date data type involve 4 bytes of storage size. And the minimum and maximum ranges of date data type start with 4713 BC to 5874897 AD or 1000-01-01 to 9999-12-31.

We can use the CURRENT_DATE after the DEFAULT keyword if we want to use the current date as the column's default value while creating a new table containing a Date column.

smallint DATATYPE

time DATATYPE



day9=# create table student(
day9(# rollno int generated always as identity,
day9(# name varchar(20) not null,
day9(# phno bigint not null,
day9(# age smallint not null,
day9(# fees decimal not null,
day9(# primary key(rollno),
day9(# gender varchar(1) default 'M',
day9(# date_of_admission date not null default current_date,
day9(# dob date not null);
CREATE TABLE
day9=# alter table taazaatraining add time_of_admission time default current_time;
ALTER TABLE
day9=# alter table student add time_of_admission time default current_time;
ALTER TABLE
day9=# insert into student(name,phno,age,fees,gender,dob) values('Mickey',9717983635,22,100.25,'M',1949-09-12);
ERROR:  column "dob" is of type date but expression is of type integer
LINE 1: ...der,dob) values('Mickey',9717983635,22,100.25,'M',1949-09-12...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
day9=# insert into student(name,phno,age,fees,gender,dob) values('Mickey',9717983635,22,100.25,'M','1949-09-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
(1 row)


day9=# insert into student(name,phno,age,fees,dob) values('donal',9733983635,32,200.25,'1939-09-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
      2 | donal  | 9733983635 |  32 | 200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492
(2 rows)


day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,100.25,'F','1949-12-12');
INSERT 0 1
day9=# select * from student;
 rollno |  name  |    phno    | age |  fees  | gender | date_of_admission |    dob     | time_of_admission
--------+--------+------------+-----+--------+--------+-------------------+------------+-------------------
      1 | Mickey | 9717983635 |  22 | 100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703
      2 | donal  | 9733983635 |  32 | 200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492
      3 | emma   | 9227983635 |  22 | 100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854
(3 rows)


day9=#

char DATATYPE

numeric DATATYPE

day9=# alter table student alter gender type char(1);
ALTER TABLE
day9=# alter table student alter fees type numberic;

day9=# alter table student alter fees type numeric;
ALTER TABLE
day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,10050000000000000000.89,'F','1949-12-12');
INSERT 0 1
day9=# insert into student(name,phno,age,fees,gender,dob) values('emma',9227983635,22,10050000000000000000.89,'F','1949-12-12');

26-08-2021 work

Why we use joins?
Whenever we want to get records from two or more tables, we will execute the joins commands.



Types of Joins
•         Inner Join
The PostgreSQL Inner Join is used to return only those records from the tables, which are equivalent to the defined condition and hides other rows and columns. In PostgreSQL, it as a default Join, therefore it is not compulsory to use the Inner Join keyword with the query.


day9=# select * from student;
 rollno |  name  |    phno    | age |          fees           | gender | date_of_admission |    dob     | time_of_admission |      faxno
--------+--------+------------+-----+-------------------------+--------+-------------------+------------+-------------------+-----------------
      1 | Mickey | 9717983635 |  22 |                  100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703   |
      2 | donal  | 9733983635 |  32 |                  200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492   |
      3 | emma   | 9227983635 |  22 |                  100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854   |
      4 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:21:07.439436   |
      5 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:23:57.308004   |
      6 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:56:11.614468   | {9826373,74348}
(6 rows)


day9=# select * from department;
 dptid | dptname | rollno |    doj     |       toj
-------+---------+--------+------------+-----------------
     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548
(7 rows)


day9=# select * from student inner join department on student.rollno=department.rollno;
 rollno |  name  |    phno    | age |          fees           | gender | date_of_admission |    dob     | time_of_admission |      faxno      | dptid | dptname | rollno |    doj     |       toj
--------+--------+------------+-----+-------------------------+--------+-------------------+------------+-------------------+-----------------+-------+---------+--------+------------+-----------------
      1 | Mickey | 9717983635 |  22 |                  100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703   |                 |     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
      2 | donal  | 9733983635 |  32 |                  200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492   |                 |     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
      3 | emma   | 9227983635 |  22 |                  100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854   |                 |     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
      4 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:21:07.439436   |                 |     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
      5 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:23:57.308004   |                 |     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
      6 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:56:11.614468   | {9826373,74348} |     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
(6 rows)


day9=# select student.rollno,name,dptname from student inner join department on student.rollno=department.rollno;
 rollno |  name  | dptname
--------+--------+---------
      1 | Mickey | CSE
      2 | donal  | IT
      3 | emma   | ECE
      4 | emma   | AI
      5 | emma   | DS
      6 | emma   | EEE
(6 rows)



•         Outer Join
left outer join


The PostgreSQL LEFT JOIN or Left Outer Join is used to return all rows from the left table and rows from the other table where the join condition is fulfilled defined in the ON condition. And if there are no corresponding records found from the right table, it will return null.

The Left Join can also be known as the Left Outer Join clause. Therefore, the Outer is the optional keyword, which is used in Left Join. In PostgreSQL, the Left join is parallel to the Inner Join condition.

day9=# select * from student;
 rollno |  name  |    phno    | age |          fees           | gender | date_of_admission |    dob     | time_of_admission |      faxno
--------+--------+------------+-----+-------------------------+--------+-------------------+------------+-------------------+-----------------
      1 | Mickey | 9717983635 |  22 |                  100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703   |
      2 | donal  | 9733983635 |  32 |                  200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492   |
      3 | emma   | 9227983635 |  22 |                  100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854   |
      4 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:21:07.439436   |
      5 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:23:57.308004   |
      6 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:56:11.614468   | {9826373,74348}
(6 rows)


day9=# select * from department;
 dptid | dptname | rollno |    doj     |       toj
-------+---------+--------+------------+-----------------
     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548
(7 rows)


day9=# select student.rollno,name,dptname from student left join department on student.rollno=department.rollno;
 rollno |  name  | dptname
--------+--------+---------
      1 | Mickey | CSE
      2 | donal  | IT
      3 | emma   | ECE
      4 | emma   | AI
      5 | emma   | DS
      6 | emma   | EEE
(6 rows)

right outer join:-
The PostgreSQL Right JOIN or Right Outer Join is used to return all rows from the right table, and rows from the other table where the join condition is fulfilled defined in the ON condition. And if there are no corresponding records found from the Left table, it will return null values.

The Right Join can also be called as the Right Outer Join clause. Therefore, the Outer is the optional keyword, which is used in Right Join. In PostgreSQL, the Right join is parallel to the Left Join condition, but it will give the opposite result of the join tables.


day9=# select * from student;
 rollno |  name  |    phno    | age |          fees           | gender | date_of_admission |    dob     | time_of_admission |      faxno
--------+--------+------------+-----+-------------------------+--------+-------------------+------------+-------------------+-----------------
      1 | Mickey | 9717983635 |  22 |                  100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703   |
      2 | donal  | 9733983635 |  32 |                  200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492   |
      3 | emma   | 9227983635 |  22 |                  100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854   |
      4 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:21:07.439436   |
      5 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:23:57.308004   |
      6 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:56:11.614468   | {9826373,74348}
(6 rows)


day9=# select * from department;
 dptid | dptname | rollno |    doj     |       toj
-------+---------+--------+------------+-----------------
     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548
(7 rows)


day9=# select student.rollno,name,dptname from student right join department on student.rollno=department.rollno;
 rollno |  name  | dptname
--------+--------+---------
      1 | Mickey | CSE
      2 | donal  | IT
      3 | emma   | ECE
      4 | emma   | AI
      5 | emma   | DS
      6 | emma   | EEE
        |        | ME
(7 rows)

full outer join :-
The PostgreSQL Full Join or Full Outer Join is used to return all records when there is a match in the left table or right table records. The main objective of a Full Outer Join is that it will combine the outcome of PostgreSQL Left Join and PostgreSQL Right Join clauses and returns all similar or unmatched rows from the tables on both sides of the join clause.


day9=# select * from student;
 rollno |  name  |    phno    | age |          fees           | gender | date_of_admission |    dob     | time_of_admission |      faxno
--------+--------+------------+-----+-------------------------+--------+-------------------+------------+-------------------+-----------------
      1 | Mickey | 9717983635 |  22 |                  100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703   |
      2 | donal  | 9733983635 |  32 |                  200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492   |
      3 | emma   | 9227983635 |  22 |                  100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854   |
      4 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:21:07.439436   |
      5 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:23:57.308004   |
      6 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:56:11.614468   | {9826373,74348}
(6 rows)


day9=# select * from department;
 dptid | dptname | rollno |    doj     |       toj
-------+---------+--------+------------+-----------------
     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548
(7 rows)


day9=# select student.rollno,name,dptname from student full join department on student.rollno=department.rollno;
 rollno |  name  | dptname
--------+--------+---------
      1 | Mickey | CSE
      2 | donal  | IT
      3 | emma   | ECE
      4 | emma   | AI
      5 | emma   | DS
      6 | emma   | EEE
        |        | ME
(7 rows)


day9=# select student.rollno,name,dptname from student full outer join department on student.rollno=department.rollno;
 rollno |  name  | dptname
--------+--------+---------
      1 | Mickey | CSE
      2 | donal  | IT
      3 | emma   | ECE
      4 | emma   | AI
      5 | emma   | DS
      6 | emma   | EEE
        |        | ME
(7 rows)


    
  •   Cross Join

The PostgreSQL Cross Join is used to combine all possibilities of the multiple tables and returns the output, which contain each row from all the selected tables. The CROSS JOIN, further known as CARTESIAN JOIN that allows us to produce the Cartesian product of all related tables.

The Cartesian product can be described as all existing rows in the first table multiplied by all rows in the second table. It is parallel to the Inner Join, where the join condition is not existing with this clause.
day9=# select * from student;
 rollno |  name  |    phno    | age |          fees           | gender | date_of_admission |    dob     | time_of_admission |      faxno
--------+--------+------------+-----+-------------------------+--------+-------------------+------------+-------------------+-----------------
      1 | Mickey | 9717983635 |  22 |                  100.25 | M      | 2021-08-25        | 1949-09-12 | 16:57:28.041703   |
      2 | donal  | 9733983635 |  32 |                  200.25 | M      | 2021-08-25        | 1939-09-12 | 16:59:25.139492   |
      3 | emma   | 9227983635 |  22 |                  100.25 | F      | 2021-08-25        | 1949-12-12 | 17:00:06.541854   |
      4 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:21:07.439436   |
      5 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:23:57.308004   |
      6 | emma   | 9227983635 |  22 | 10050000000000000000.89 | F      | 2021-08-25        | 1949-12-12 | 17:56:11.614468   | {9826373,74348}
(6 rows)


day9=# select * from department;
 dptid | dptname | rollno |    doj     |       toj
-------+---------+--------+------------+-----------------
     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548
(7 rows)


day9=# select student.rollno,name,dptname from student cross join department on student.rollno=department.rollno;
ERROR:  syntax error at or near "on"
LINE 1: ...o,name,dptname from student cross join department on student...
                                                             ^
day9=# select student.rollno,name,dptname from student cross join department ;
 rollno |  name  | dptname
--------+--------+---------
      1 | Mickey | CSE
      2 | donal  | CSE
      3 | emma   | CSE
      4 | emma   | CSE
      5 | emma   | CSE
      6 | emma   | CSE
      1 | Mickey | IT
      2 | donal  | IT
      3 | emma   | IT
      4 | emma   | IT
      5 | emma   | IT
      6 | emma   | IT
      1 | Mickey | ECE
      2 | donal  | ECE
      3 | emma   | ECE
      4 | emma   | ECE
      5 | emma   | ECE
      6 | emma   | ECE
      1 | Mickey | AI
      2 | donal  | AI
      3 | emma   | AI
      4 | emma   | AI
      5 | emma   | AI
      6 | emma   | AI
      1 | Mickey | DS
      2 | donal  | DS
      3 | emma   | DS
      4 | emma   | DS
      5 | emma   | DS
      6 | emma   | DS
      1 | Mickey | EEE
      2 | donal  | EEE
      3 | emma   | EEE
      4 | emma   | EEE
      5 | emma   | EEE
      6 | emma   | EEE
      1 | Mickey | ME
      2 | donal  | ME
      3 | emma   | ME
      4 | emma   | ME
      5 | emma   | ME
      6 | emma   | ME
(42 rows)
 6*7=42 rows



•         Self-Join
In PostgreSQL, we have one particular type of join, which is known as Self Join. The "PostgreSQL Self Join is used to set the different names of a similar table completely, and we can use the aliases also.

To proceed a self-join, we will define a similar table two times with different table aliases and give the Join predicate after the ON keyword.

In real-time, we use a self-join to compare rows within the same table (because the comparison of similar table name is not allowed in PostgreSQL), and to fetch the hierarchical data.

day9=# select * from department c inner join department o on c.dptid=o.dptid;
 dptid | dptname | rollno |    doj     |       toj       | dptid | dptname | rollno |    doj     |       toj
-------+---------+--------+------------+-----------------+-------+---------+--------+------------+-----------------
     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238 |     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582  |     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661 |     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417 |     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976 |     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247 |     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548 |     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548
(7 rows)


day9=# select * from department;
 dptid | dptname | rollno |    doj     |       toj
-------+---------+--------+------------+-----------------
     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548
(7 rows)


day9=# select * from department c inner join department o on c.dptid=o.dptid;
 dptid | dptname | rollno |    doj     |       toj       | dptid | dptname | rollno |    doj     |       toj
-------+---------+--------+------------+-----------------+-------+---------+--------+------------+-----------------
     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238 |     1 | CSE     |      1 | 2021-08-26 | 15:19:14.604238
     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582  |     2 | IT      |      2 | 2021-08-26 | 15:19:24.54582
     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661 |     3 | ECE     |      3 | 2021-08-26 | 15:19:35.171661
     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417 |     4 | AI      |      4 | 2021-08-26 | 15:19:43.955417
     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976 |     5 | DS      |      5 | 2021-08-26 | 15:19:52.605976
     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247 |     6 | EEE     |      6 | 2021-08-26 | 15:20:03.292247
     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548 |     7 | ME      |      7 | 2021-08-26 | 15:20:17.471548
(7 rows)


day9=# select dptid,dptname,rollno from department c inner join department o on c.dptid=o.dptid;
ERROR:  column reference "dptid" is ambiguous
LINE 1: select dptid,dptname,rollno from department c inner join dep...
               ^
day9=# select c.dptid,o.dptname,c.rollno from department c inner join department o on c.dptid=o.dptid;
 dptid | dptname | rollno
-------+---------+--------
     1 | CSE     |      1
     2 | IT      |      2
     3 | ECE     |      3
     4 | AI      |      4
     5 | DS      |      5
     6 | EEE     |      6
     7 | ME      |      7
(7 rows)

Natural join works same as inner join

•         Union

The PostgreSQL UNION clause/operator is used to combine the results of two or more SELECT statements without returning any duplicate rows.

To use UNION, each SELECT must have the same number of columns selected, the same number of column expressions, the same data type, and have them in the same order but they do not have to be the same length.

Syntax
The basic syntax of UNION is as follows −

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

•         Intersect

•         Understanding Views
•         Need of Views
•         Creating, Altering and Dropping Views
•         Simple and Complex Views






































































































